----------------------------------------------------------------------
List循環類:
----------------------------------------------------------------------
list_for_each(pos, head)

list_for_each_entry(pos, head, member)

list_entry(ptr, type, member)

offsetof(TYPE, MEMBER)







----------------------------------------------------------------------
vmlinux image作成時の優先度マクロ:
Section Property
    include/linux/init.h
----------------------------------------------------------------------
#define __define_initcall(fn, id) \
　    static initcall_t __initcall_##fn##id __used \
	    __attribute__((__section__(".initcall" #id ".init"))) = fn;         //fn関数を、特定のproperty sectionに配置してる
  


#define pure_initcall(fn)		__define_initcall(fn, 0)

#define core_initcall(fn)		__define_initcall(fn, 1)
#define core_initcall_sync(fn)		__define_initcall(fn, 1s)
#define postcore_initcall(fn)		__define_initcall(fn, 2)
#define postcore_initcall_sync(fn)	__define_initcall(fn, 2s)
#define arch_initcall(fn)		__define_initcall(fn, 3)
#define arch_initcall_sync(fn)		__define_initcall(fn, 3s)
#define subsys_initcall(fn)		__define_initcall(fn, 4)
#define subsys_initcall_sync(fn)	__define_initcall(fn, 4s)
#define fs_initcall(fn)			__define_initcall(fn, 5)
#define fs_initcall_sync(fn)		__define_initcall(fn, 5s)
#define rootfs_initcall(fn)		__define_initcall(fn, rootfs)
#define device_initcall(fn)		__define_initcall(fn, 6)
#define device_initcall_sync(fn)	__define_initcall(fn, 6s)
#define late_initcall(fn)		__define_initcall(fn, 7)
#define late_initcall_sync(fn)		__define_initcall(fn, 7s)

例:
subsys_initcall(gpio_mxc_init);               //機能: マクロで宣言した関数を、特定のSectionに配置する(.initcall4.init)

    static int __init gpio_mxc_init(void)
    {
	    return platform_driver_register(&mxc_gpio_driver);
    }


----------------------------------------------------------------------
.ko moduleマクロ:
      優先度6
      include/linux/module.h
----------------------------------------------------------------------
#define module_init(x)	__initcall(x);

    展開すると:
    module_init
        __initcall
            device_initcall
                __define_initcall("6",fn,6)


#define module_exit(x)	__exitcall(x);

----------------------------------------------------------------------
vmlinux section list:
	kernelをbuildをしたら、/arch/arm/kernel/vmlinux.lds が生成されるので、中身見れば分かる
----------------------------------------------------------------------
...
.initcall4.init
...



SECTIONS
{
 . = 0xC0000000 + 0x00008000;
 .init : { /* Init code and data                */
  _stext = .;
  _sinittext = .;
   *(.head.text)
   *(.init.text) *(.cpuinit.text) *(.meminit.text)
  ......
  . = ALIGN(16); __setup_start = .; *(.init.setup) __setup_end = .;
  __initcall_start = .; *(.initcallearly.init) __early_initcall_end = .;
 *(.initcall0.init) *(.initcall0s.init)  *(.initcall1.init) *(.initcall1s.init) 
 *(.initcall2.init) ... __initcall_end = .;
 ...



問:
　kernelは、起動時に、たくさんの作業をやる必要があると思うが、 どうやって、順番を守りながら、初期化してるのか？
答:
　まず、kernelは、すべての起動時に実行が必要な関数を、Levelにより、1~8まで、分類している。
 ㅠㅕㅜㅜ
　まず、kernelは、すべての起動時に実行が必要な関数を、Levelにより
 内核的解决方案就是给内核启动时要调用的所有函数归类，执行内核某一个函数然后每个类就会按照一定的次序被调用执行。
 这些分类名就叫.initcallx.init。x的值从1到8。
 内核开发者在编写内核代码时只要将函数设置合适的级别，这些函数就会被链接的时候放入特定的段，
 内核启动时再按照段顺序去依次执行各个段即可（通过某一个函数，链接脚本只是规定了某一程序段在内存中的存放位置）。
